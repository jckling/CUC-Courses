## 自底向上 - 算符优先分析python实现

### 算符优先分析 - 计算器
因为算符优先分析只考虑算符之间的优先关系，不适用于大多的语言的文法，但其适合于算术表达式，因此就可以用于编写计算器

### 功能实现
1. 符号优先级
```python
# 除了+、-、*、/、(、)之外的都是自行添(nao)加(bu)的
priority = [
        #+    -    *    /    (    )    #    %    e    ^   sin( cos( tan( asin(acos(atan(
        ['>', '>', '<', '<', '<', '>', '>', '<', '<', '<', '<', '<', '<', '<', '<', '<'],  # +
        ['>', '>', '<', '<', '<', '>', '>', '<', '<', '<', '<', '<', '<', '<', '<', '<'],  # -
        ['>', '>', '>', '>', '<', '>', '>', '<', '>', '>', '<', '<', '<', '<', '<', '<'],  # *
        ['>', '>', '>', '>', '<', '>', '>', '>', '>', '>', '<', '<', '<', '<', '<', '<'],  # /
        ['<', '<', '<', '<', '<', '=', '0', '<', '<', '<', '<', '<', '<', '<', '<', '<'],  # (
        ['>', '>', '>', '>', '0', '>', '>', '>', '>', '>', '0', '0', '0', '0', '0', '0'],  # )
        ['<', '<', '<', '<', '<', '0', '=', '<', '<', '<', '<', '<', '<', '<', '<', '<'],  # #
        ['>', '>', '>', '>', '<', '>', '>', '>', '>', '>', '<', '<', '<', '<', '<', '<'],  # %
        ['>', '>', '>', '>', '<', '>', '>', '>', '>', '>', '<', '<', '<', '<', '<', '<'],  # e
        ['>', '>', '>', '>', '<', '>', '>', '>', '>', '>', '<', '<', '<', '<', '<', '<'],  # ^
        ['<', '<', '<', '<', '<', '=', '0', '<', '<', '<', '<', '<', '<', '<', '<', '<'],  # sin(
        ['<', '<', '<', '<', '<', '=', '0', '<', '<', '<', '<', '<', '<', '<', '<', '<'],  # cos(
        ['<', '<', '<', '<', '<', '=', '0', '<', '<', '<', '<', '<', '<', '<', '<', '<'],  # tan(
        ['<', '<', '<', '<', '<', '=', '0', '<', '<', '<', '<', '<', '<', '<', '<', '<'],  # asin(
        ['<', '<', '<', '<', '<', '=', '0', '<', '<', '<', '<', '<', '<', '<', '<', '<'],  # acos(
        ['<', '<', '<', '<', '<', '=', '0', '<', '<', '<', '<', '<', '<', '<', '<', '<'],  # atan(
    ]
```


2. 运算函数
+、-、*、/、%、^、e、sin、cos、tan、asin、acos、atan
其中三角函数使用math库中的函数实现
```python
def operator_function(number1, number2):
    ...
    return result
```


3. 获得当前最上面的运算符
```python
# 栈中的运算符
def get_operator(stack):
    for i in stack[::-1]:
        if i in operator or i == '#':
            return i
```

4. 主函数
将算术表达式（字符串）从左往右依次压入栈（列表）中
```python
# 栈初始化
stack = ['#']

# 记录入栈的数字（可能不止一位）
number = ''

# 入栈并计算
for s in expression:
    if s not in operator:           # 如果不是操作符，那一定是数字或小数点
        number = number + s
    else:
        stack.append(number)        # 遇到操作符，将当前数字压栈
        number = ''                 # 清空
        while True:
            top_operator = get_operator(stack)
            if priority(s, top_operator) == '>':                # 如果当前待入栈的运算符的优先级大于栈中最上面的运算符
                b, o, a = stack.pop(), stack.pop(), stack.pop() # 弹出操作数、操作符进行计算
                result = do operator_function
                stack.append(result)                            # 将结果入栈
            else:
                break
        stack.append(s)             # 将当前运算符入栈

# 最后在栈中的结果就是表达式的计算结果
final_result = stack[1]
```

5. 其他 - 字符转数字
```python
# 输入串x、y，返回对应的数字
try:
    a, b = int(x), int(y)
except ValueError:
    a, b = float(x), float(y)
```

6. 其他 - 错误处理
小数点左右一定是数字，符号 `e` 的左右也一定是数字
```python
if re.findall('([^\d+]\.)|(\.[^\d])', expression):   # 小数点两边必须有数字
    print('小数点输入错误')
    exit(0)

if 'e' in expression and not re.findall('[\d+]e[\d+]', expression):    # e两边必须有数字
    print('e左右必须有数字')
    exit(0)
```

### 测试
```bash
注意：三角函数的输入为角度
请输入算数表达式：10*sin(90)/5+2^3%3+(-3)*3
10*sin(90)/5+2^3%3+(-3)*3 = -5.0

请输入算数表达式：2.5*4+5e10-10
2.5*4+5e10-10 = 50000000000.0

请输入算数表达式：-2*5-9%8+1000*2*sin(90)
-2*5-9%8+1000*2*sin(90) = 1989.0

请输入算数表达式：10^2-2.5*10
10^2-2.5*10 = 75.0

请输入算数表达式：1/3
1/3 = 0.3333333333333333
```

### 总结
- 以上只是给出了示意的实现，具体实现请参看 [Caculator.py](Caculator.py)
- 代码只是为了实现算符优先分析，因此运算是直接调用函数
