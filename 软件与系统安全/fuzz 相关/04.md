# [libfuzzer-workshop/lessons/04](https://github.com/Dor1s/libfuzzer-workshop/tree/master/lessons/04)

## 基本的溢出

根据 `fuzz target` 形式编写的存在缓冲区溢出漏洞的函数
- 接受字节数组、大小作为参数
- 显然当 `size=3` 时会发生缓冲区溢出

```c
bool VulnerableFunction1(const uint8_t* data, size_t size) {
  bool result = false;
  if (size >= 3) {
    result = data[0] == 'F' &&
             data[1] == 'U' &&
             data[2] == 'Z' &&
             data[3] == 'Z';
  }

  return result;
}
```

编写 fuzzer ，libfuzzer 的基本形式如下，以字节数组、大小作为参数，使用被测 API 处理接收的数据
- 与上面编写的函数参数相同，因此可直接作为被测 API 的参数
- `data` 为随机数据，`size` 默认为 64

```cpp
#include "vulnerable_functions.h"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  VulnerableFunction1(data, size);
  return 0;
}
```

编译 fuzzer
- 看到 clang 、 LLVM 后知后觉想到了编译原理；抽象语法树 AST 相关只了解过概念，当初对着 java 源码表示无力

```bash
# clang++   编译器
# -g        详细调试信息
# -std      指定语言
# -o        写入文件
# -fsanitize=address                    使用 ASAN
# -fsanitize-coverage=trace-pc-guard    提供代码覆盖率信息
clang++ -g -std=c++11 -fsanitize=address -fsanitize-coverage=trace-pc-guard \
    first_fuzzer.cc ../../libFuzzer/libFuzzer.a \
    -o first_fuzzer
```

运行 fuzzer
- 新建文件夹作为语料库(corpus)
    - 空文件夹表示没有任何初始种子/样本
    - 若找到了测试代码中先前未覆盖的路径执行，则将当前数据保存到语料库
    - 基于当前语料库中的样本生成随机突变
- 在语料库的基础上运行 fuzzer

```bash
# 创建语料库
mkdir corpus1

# 解析为源代码行号和文件名
ASAN_OPTIONS=symbolize=1 ./first_fuzzer corpus1
```

<details>
<summary> 运行结果 </summary><br>

```bash
INFO: Seed: 3668597535
INFO: Loaded 1 modules (36 guards): [0x771ea0, 0x771f30), 
Loading corpus dir: corpus1
INFO: -max_len is not provided, using 64
INFO: A corpus is not provided, starting from an empty corpus
#0	READ units: 1
#1	INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 28Mb
#3	NEW    cov: 4 ft: 4 corp: 2/10b exec/s: 0 rss: 29Mb L: 9 MS: 2 CopyPart-CMP- DE: "\xff\xff\xff\xff\xff\xff\xff\xff"-
#4275	NEW    cov: 5 ft: 5 corp: 3/13b exec/s: 0 rss: 29Mb L: 3 MS: 4 ChangeBit-ChangeBinInt-CMP-ChangeByte- DE: "\x01\x00"-
#46818	NEW    cov: 6 ft: 6 corp: 4/16b exec/s: 0 rss: 32Mb L: 3 MS: 2 ChangeBit-ChangeByte-
#104567	NEW    cov: 7 ft: 7 corp: 5/20b exec/s: 0 rss: 38Mb L: 4 MS: 1 InsertByte-
=================================================================
==2702==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020001e3693 at pc 0x000000513350 bp 0x7ffd45d72e40 sp 0x7ffd45d72e38
READ of size 1 at 0x6020001e3693 thread T0
    #0 0x51334f in VulnerableFunction1(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:22:14
    #1 0x51398e in LLVMFuzzerTestOneInput /home/fuzzer/projects/libfuzzer-workshop/lessons/04/first_fuzzer.cc:10:3
    #2 0x51e4d3 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:451:13
    #3 0x51e700 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:408:3
    #4 0x51f0eb in fuzzer::Fuzzer::MutateAndTestOne() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:587:30
    #5 0x51f347 in fuzzer::Fuzzer::Loop() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:615:5
    #6 0x517294 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerDriver.cpp:644:6
    #7 0x513f70 in main /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerMain.cpp:20:10
    #8 0x7fa6f36d882f in __libc_start_main /build/glibc-t3gR2i/glibc-2.23/csu/../csu/libc-start.c:291
    #9 0x41c868 in _start (/home/fuzzer/projects/libfuzzer-workshop/lessons/04/first_fuzzer+0x41c868)

0x6020001e3693 is located 0 bytes to the right of 3-byte region [0x6020001e3690,0x6020001e3693)
allocated by thread T0 here:
    #0 0x50ef80 in operator new[](unsigned long) /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:84
    #1 0x51e419 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:442:23
    #2 0x51e700 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:408:3
    #3 0x51f0eb in fuzzer::Fuzzer::MutateAndTestOne() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:587:30
    #4 0x51f347 in fuzzer::Fuzzer::Loop() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:615:5
    #5 0x517294 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerDriver.cpp:644:6
    #6 0x513f70 in main /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerMain.cpp:20:10
    #7 0x7fa6f36d882f in __libc_start_main /build/glibc-t3gR2i/glibc-2.23/csu/../csu/libc-start.c:291

SUMMARY: AddressSanitizer: heap-buffer-overflow /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:22:14 in VulnerableFunction1(unsigned char const*, unsigned long)
Shadow bytes around the buggy address:
  0x0c0480034680: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
  0x0c0480034690: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd
  0x0c04800346a0: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa
  0x0c04800346b0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
  0x0c04800346c0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
=>0x0c04800346d0: fa fa[03]fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c04800346e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c04800346f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c0480034700: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c0480034710: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c0480034720: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==2702==ABORTING
MS: 1 EraseBytes-; base unit: 0083b39cabd56f9e99c687eef892b0747fb60f95
0x46,0x55,0x5a,
FUZ
artifact_prefix='./'; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60
Base64: RlVa
```

</details>

- 程序由于 `heap-buffer-overflow` 而崩溃(crash)，具体发生的位置在 `VulnerableFunction1` 函数，同时生成 `crash-xxxxx` 文件
- 种子数据为 3668597535
- 覆盖率为 7
- 崩溃时的数据保存到 `crash-*` 文件
- 复现崩溃 `./first_fuzzer crash-*`
- AddressSanitizer 显示了发生溢出的具体位置

## 逻辑稍微复杂的溢出

四个 `if` 条件语句拦不住错误的长度校验

```c
constexpr auto kMagicHeader = "ZN_2016";
constexpr std::size_t kMaxPacketLen = 1024;
constexpr std::size_t kMaxBodyLength = 1024 - sizeof(kMagicHeader);

bool VulnerableFunction2(const uint8_t* data, size_t size, bool verify_hash) {
  if (size < sizeof(kMagicHeader))  // 大小小于 kMagicHeader 返回 false
    return false;

  std::string header(reinterpret_cast<const char*>(data), sizeof(kMagicHeader));  // 输入数据转化为 char *

  std::array<uint8_t, kMaxBodyLength> body;   // 1024 - sizeof(kMagicHeader);

  if (strcmp(kMagicHeader, header.c_str())) // 字符和 kMagicHeader 相同返回 false
    return false;

  auto target_hash = data[--size];  // 没有校验 size

  if (size > kMaxPacketLen) // 大小大于 1024 则返回 false，这里应该用 kMaxBodyLength
    return false;

  if (!verify_hash) // verify_hash 为假返回 true
    return true;

  std::copy(data, data + size, body.data());  // 将 data 拷贝到 body 数组，存在溢出的可能性
  auto real_hash = DummyHash(body);
  return real_hash == target_hash;
}
```

编写 fuzzer
- 由于第三个参数是 `bool` 型变量，因此可分为真/假/真假三种测试

```cpp
#include "vulnerable_functions.h"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  VulnerableFunction2(data, size, false);
  // VulnerableFunction2(data, size, true);
  return 0;
}
```

编译 fuzzer
- 同上一节中的编译方法

```bash
clang++ -g -std=c++11 -fsanitize=address -fsanitize-coverage=trace-pc-guard \
    second_fuzzer.cc ../../libFuzzer/libFuzzer.a \
    -o second_fuzzer
```

运行 fuzzer
- 暂时没有用 `-max_len` 设置最大的数据长度，因此跑了很久也没崩溃
- 可以看出代码的覆盖率是不同的
  - 单独测试 `false` 的情况下为 5
  - 单独测试 `true` 的情况下为 22
  - 同时测试 `false` 和 `true` 的情况下为 23

<details>
<summary> 运行结果 </summary><br>

```bash
# false
INFO: Seed: 2561495012
INFO: Loaded 1 modules (36 guards): [0x771ea0, 0x771f30), 
Loading corpus dir: corpus2-false
INFO: -max_len is not provided, using 64
INFO: A corpus is not provided, starting from an empty corpus
#0	READ units: 1
#1	INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 29Mb
#3	NEW    cov: 4 ft: 4 corp: 2/25b exec/s: 0 rss: 29Mb L: 24 MS: 2 ChangeBit-InsertRepeatedBytes-
#15259	NEW    cov: 5 ft: 5 corp: 3/66b exec/s: 0 rss: 30Mb L: 41 MS: 3 CopyPart-ChangeBinInt-CMP- DE: "ZN_2016"-
#1048576	pulse  cov: 5 ft: 5 corp: 3/66b exec/s: 524288 rss: 111Mb
#2097152	pulse  cov: 5 ft: 5 corp: 3/66b exec/s: 419430 rss: 191Mb
#4194304	pulse  cov: 5 ft: 5 corp: 3/66b exec/s: 381300 rss: 351Mb
#8388608	pulse  cov: 5 ft: 5 corp: 3/66b exec/s: 364722 rss: 504Mb
#16777216	pulse  cov: 5 ft: 5 corp: 3/66b exec/s: 372827 rss: 504Mb
#33554432	pulse  cov: 5 ft: 5 corp: 3/66b exec/s: 364722 rss: 504Mb
#67108864	pulse  cov: 5 ft: 5 corp: 3/66b exec/s: 209061 rss: 504Mb
^C==2755== libFuzzer: run interrupted; exiting


# true
INFO: Seed: 3959337315
INFO: Loaded 1 modules (36 guards): [0x771ea0, 0x771f30), 
Loading corpus dir: corpus2-true
INFO: -max_len is not provided, using 64
INFO: A corpus is not provided, starting from an empty corpus
#0	READ units: 1
#1	INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 29Mb
#2	NEW    cov: 4 ft: 4 corp: 2/41b exec/s: 0 rss: 29Mb L: 40 MS: 1 InsertRepeatedBytes-
#5791	NEW    cov: 22 ft: 22 corp: 3/51b exec/s: 0 rss: 29Mb L: 10 MS: 5 CopyPart-ChangeBit-CMP-CMP-CMP- DE: "\xff\xff\xff\xff\xff\xff\xff\xff"-"\x00\x00\x00\x00"-"ZN_2016"-
#524288	pulse  cov: 22 ft: 22 corp: 3/51b exec/s: 174762 rss: 63Mb
#1048576	pulse  cov: 22 ft: 22 corp: 3/51b exec/s: 174762 rss: 97Mb
#2097152	pulse  cov: 22 ft: 22 corp: 3/51b exec/s: 174762 rss: 160Mb
#4194304	pulse  cov: 22 ft: 22 corp: 3/51b exec/s: 190650 rss: 277Mb
#8388608	pulse  cov: 22 ft: 22 corp: 3/51b exec/s: 155344 rss: 352Mb
#16777216	pulse  cov: 22 ft: 22 corp: 3/51b exec/s: 129055 rss: 352Mb
#33554432	pulse  cov: 22 ft: 22 corp: 3/51b exec/s: 106861 rss: 352Mb
^C==2843== libFuzzer: run interrupted; exiting


# true、false
INFO: Seed: 3054537740
INFO: Loaded 1 modules (36 guards): [0x771ea0, 0x771f30), 
Loading corpus dir: corpus2
INFO: -max_len is not provided, using 64
INFO: A corpus is not provided, starting from an empty corpus
#0	READ units: 1
#1	INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 28Mb
#2	NEW    cov: 4 ft: 4 corp: 2/12b exec/s: 0 rss: 28Mb L: 11 MS: 1 InsertRepeatedBytes-
#3534	NEW    cov: 23 ft: 23 corp: 3/23b exec/s: 0 rss: 29Mb L: 11 MS: 3 ChangeBinInt-ChangeBit-CMP- DE: "ZN_2016"-
#262144	pulse  cov: 23 ft: 23 corp: 3/23b exec/s: 87381 rss: 47Mb
#524288	pulse  cov: 23 ft: 23 corp: 3/23b exec/s: 74898 rss: 64Mb
#1048576	pulse  cov: 23 ft: 23 corp: 3/23b exec/s: 87381 rss: 95Mb
#2097152	pulse  cov: 23 ft: 23 corp: 3/23b exec/s: 91180 rss: 153Mb
#4194304	pulse  cov: 23 ft: 23 corp: 3/23b exec/s: 87381 rss: 201Mb
#8388608	pulse  cov: 23 ft: 23 corp: 3/23b exec/s: 92182 rss: 216Mb
#16777216	pulse  cov: 23 ft: 23 corp: 3/23b exec/s: 86037 rss: 240Mb
^C==2884== libFuzzer: run interrupted; exiting
```

</details><br>

从代码可以看出接受最大为 1024 长度的数据，因此使用 `-max_len=1024` 设置最大的数据长度，程序很快就崩溃 `stack-buffer-overflow`
- 输入 `false` 时会返回 true 因此不会触发
- 从崩溃信息可以看出
  - `vulnerable_functions.h:61:3` 第 61 行第 3 列的操作产生了 `stack-buffer-overflow`
  - `VulnerableFunction2` 函数中有三个对象，`body` 对象产生了内存访问溢出
- 从代码覆盖率率看出
  - 单独测试 `true` 的情况下为 22
  - 同时测试 `false` 和 `true` 的情况下为 23
  - 之前不崩溃的原因是数据长度不够，路径覆盖率是一样的

<details>
<summary> 运行结果 </summary><br>

```bash
# true
INFO: Seed: 625463074
INFO: Loaded 1 modules (36 guards): [0x771ea0, 0x771f30), 
Loading corpus dir: corpus2-true/
INFO: A corpus is not provided, starting from an empty corpus
#0	READ units: 1
#1	INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 29Mb
#8	NEW    cov: 4 ft: 4 corp: 2/11b exec/s: 0 rss: 29Mb L: 10 MS: 2 InsertByte-CMP- DE: "\x00\x00\x00\x00\x00\x00\x00\x00"-
#1200	NEW    cov: 22 ft: 22 corp: 3/21b exec/s: 0 rss: 29Mb L: 10 MS: 4 ChangeByte-ChangeBinInt-ChangeByte-CMP- DE: "ZN_2016"-
=================================================================
==3010==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffeec636a88 at pc 0x0000004bf479 bp 0x7ffeec6364d0 sp 0x7ffeec635c80
WRITE of size 1023 at 0x7ffeec636a88 thread T0
    #0 0x4bf478 in __asan_memmove /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors.cc:463
    #1 0x513df0 in unsigned char* std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<unsigned char>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:384:6
    #2 0x513cc2 in unsigned char* std::__copy_move_a<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:401:14
    #3 0x513c20 in unsigned char* std::__copy_move_a2<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:438:18
    #4 0x513a63 in unsigned char* std::copy<unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:470:15
    #5 0x513702 in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:61:3
    #6 0x513993 in LLVMFuzzerTestOneInput /home/fuzzer/projects/libfuzzer-workshop/lessons/04/second_fuzzer.cc:10:3
    #7 0x51e4e3 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:451:13
    #8 0x51e710 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:408:3
    #9 0x51f0fb in fuzzer::Fuzzer::MutateAndTestOne() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:587:30
    #10 0x51f357 in fuzzer::Fuzzer::Loop() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:615:5
    #11 0x5172a4 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerDriver.cpp:644:6
    #12 0x513f80 in main /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerMain.cpp:20:10
    #13 0x7f4edb48282f in __libc_start_main /build/glibc-t3gR2i/glibc-2.23/csu/../csu/libc-start.c:291
    #14 0x41c868 in _start (/home/fuzzer/projects/libfuzzer-workshop/lessons/04/second_fuzzer_true+0x41c868)

Address 0x7ffeec636a88 is located in stack of thread T0 at offset 1128 in frame
    #0 0x51338f in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:42

  This frame has 3 object(s):
    [32, 64) 'header'
    [96, 97) 'ref.tmp'
    [112, 1128) 'body' <== Memory access at offset 1128 overflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors.cc:463 in __asan_memmove
Shadow bytes around the buggy address:
  0x10005d8bed00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10005d8bed10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10005d8bed20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10005d8bed30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10005d8bed40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x10005d8bed50: 00[f3]f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3
  0x10005d8bed60: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00
  0x10005d8bed70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10005d8bed80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10005d8bed90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10005d8beda0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==3010==ABORTING
MS: 2 CopyPart-CrossOver-; base unit: 47e4e6220b60253ab017befdefe63d08a2f92056
artifact_prefix='./'; Test unit written to ./crash-476705eca0c3803cb1d93e0438a09b4803b5ba41

# true、false
INFO: Seed: 3179055732
INFO: Loaded 1 modules (36 guards): [0x771ea0, 0x771f30), 
Loading corpus dir: corpus2
INFO: A corpus is not provided, starting from an empty corpus
#0	READ units: 1
#1	INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 29Mb
#36	NEW    cov: 4 ft: 4 corp: 2/22b exec/s: 0 rss: 29Mb L: 21 MS: 5 ChangeByte-ChangeByte-ChangeByte-ChangeBinInt-InsertRepeatedBytes-
#43404	NEW    cov: 23 ft: 23 corp: 3/44b exec/s: 0 rss: 43Mb L: 22 MS: 3 InsertRepeatedBytes-EraseBytes-CMP- DE: "ZN_2016"-
=================================================================
==3013==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc2a51b168 at pc 0x0000004bf479 bp 0x7ffc2a51abb0 sp 0x7ffc2a51a360
WRITE of size 1023 at 0x7ffc2a51b168 thread T0
    #0 0x4bf478 in __asan_memmove /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors.cc:463
    #1 0x513e00 in unsigned char* std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<unsigned char>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:384:6
    #2 0x513cd2 in unsigned char* std::__copy_move_a<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:401:14
    #3 0x513c30 in unsigned char* std::__copy_move_a2<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:438:18
    #4 0x513a73 in unsigned char* std::copy<unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:470:15
    #5 0x513702 in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:61:3
    #6 0x513993 in LLVMFuzzerTestOneInput /home/fuzzer/projects/libfuzzer-workshop/lessons/04/second_fuzzer.cc:10:3
    #7 0x51e4f3 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:451:13
    #8 0x51e720 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:408:3
    #9 0x51f10b in fuzzer::Fuzzer::MutateAndTestOne() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:587:30
    #10 0x51f367 in fuzzer::Fuzzer::Loop() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:615:5
    #11 0x5172b4 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerDriver.cpp:644:6
    #12 0x513f90 in main /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerMain.cpp:20:10
    #13 0x7f530a66182f in __libc_start_main /build/glibc-t3gR2i/glibc-2.23/csu/../csu/libc-start.c:291
    #14 0x41c868 in _start (/home/fuzzer/projects/libfuzzer-workshop/lessons/04/second_fuzzer+0x41c868)

Address 0x7ffc2a51b168 is located in stack of thread T0 at offset 1128 in frame
    #0 0x51338f in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:42

  This frame has 3 object(s):
    [32, 64) 'header'
    [96, 97) 'ref.tmp'
    [112, 1128) 'body' <== Memory access at offset 1128 overflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors.cc:463 in __asan_memmove
Shadow bytes around the buggy address:
  0x10000549b5d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000549b5e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000549b5f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000549b600: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000549b610: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x10000549b620: 00 00 00 00 00 00 00 00 00 00 00 00 00[f3]f3 f3
  0x10000549b630: f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3
  0x10000549b640: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000549b650: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000549b660: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x10000549b670: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==3013==ABORTING
MS: 5 CrossOver-CMP-ChangeBit-CrossOver-CrossOver- DE: "\x0acccccc"-; base unit: dece8ef7b879dcaf3d89f04a52afc2ff14e5de71
artifact_prefix='./'; Test unit written to ./crash-9b5bdf0975823ebb14d0a3846274ce417ec222be
```

</details><br>

去掉一个基本块的内容进行覆盖率测试
- 注释后再次生成 fuzzer

```c
  if (!verify_hash)
    return true;
```

<details>
<summary> 运行结果 </summary><br>

```bash
# true
INFO: Seed: 2749705393
INFO: Loaded 1 modules (35 guards): [0x771ea0, 0x771f2c), 
Loading corpus dir: corpus2-true/
INFO: A corpus is not provided, starting from an empty corpus
#0	READ units: 1
#1	INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 27Mb
#5	NEW    cov: 4 ft: 4 corp: 2/51b exec/s: 0 rss: 27Mb L: 50 MS: 4 InsertByte-CopyPart-InsertByte-InsertRepeatedBytes-
#4321	NEW    cov: 22 ft: 22 corp: 3/60b exec/s: 0 rss: 29Mb L: 9 MS: 5 ChangeBit-CMP-CMP-ShuffleBytes-CMP- DE: "\x01\x00\x00\x00\x00\x00\x00\x00"-"\x00\x00\x00\x00\x00\x00\x00\x00"-"ZN_2016"-
=================================================================
==3113==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff268d01c8 at pc 0x0000004bf479 bp 0x7fff268cfc10 sp 0x7fff268cf3c0
WRITE of size 1023 at 0x7fff268d01c8 thread T0
    #0 0x4bf478 in __asan_memmove /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors.cc:463
    #1 0x513dd0 in unsigned char* std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<unsigned char>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:384:6
    #2 0x513ca2 in unsigned char* std::__copy_move_a<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:401:14
    #3 0x513c00 in unsigned char* std::__copy_move_a2<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:438:18
    #4 0x513a43 in unsigned char* std::copy<unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:470:15
    #5 0x5136c9 in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:61:3
    #6 0x513963 in LLVMFuzzerTestOneInput /home/fuzzer/projects/libfuzzer-workshop/lessons/04/second_fuzzer.cc:10:3
    #7 0x51e4c3 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:451:13
    #8 0x51e6f0 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:408:3
    #9 0x51f0db in fuzzer::Fuzzer::MutateAndTestOne() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:587:30
    #10 0x51f337 in fuzzer::Fuzzer::Loop() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:615:5
    #11 0x517284 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerDriver.cpp:644:6
    #12 0x513f60 in main /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerMain.cpp:20:10
    #13 0x7fafaec5582f in __libc_start_main /build/glibc-t3gR2i/glibc-2.23/csu/../csu/libc-start.c:291
    #14 0x41c868 in _start (/home/fuzzer/projects/libfuzzer-workshop/lessons/04/second_fuzzer_true+0x41c868)

Address 0x7fff268d01c8 is located in stack of thread T0 at offset 1128 in frame
    #0 0x51338f in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:42

  This frame has 3 object(s):
    [32, 64) 'header'
    [96, 97) 'ref.tmp'
    [112, 1128) 'body' <== Memory access at offset 1128 overflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors.cc:463 in __asan_memmove
Shadow bytes around the buggy address:
  0x100064d11fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100064d11ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100064d12000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100064d12010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100064d12020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x100064d12030: 00 00 00 00 00 00 00 00 00[f3]f3 f3 f3 f3 f3 f3
  0x100064d12040: f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 00 00 00 00
  0x100064d12050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100064d12060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100064d12070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100064d12080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==3113==ABORTING
MS: 1 CrossOver-; base unit: ddcf4d4dfdecfdf0b110e3dfa264958fb8733a86
artifact_prefix='./'; Test unit written to ./crash-c70c91144f1b0ae2737d79b668a845c5827deebd


# true、false
INFO: Seed: 4293832217
INFO: Loaded 1 modules (35 guards): [0x771ea0, 0x771f2c), 
Loading corpus dir: corpus2
INFO: A corpus is not provided, starting from an empty corpus
#0	READ units: 1
#1	INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 29Mb
#11	NEW    cov: 4 ft: 4 corp: 2/69b exec/s: 0 rss: 29Mb L: 68 MS: 5 ChangeBit-InsertByte-EraseBytes-CopyPart-InsertRepeatedBytes-
#11609	NEW    cov: 22 ft: 22 corp: 3/78b exec/s: 0 rss: 33Mb L: 9 MS: 3 ChangeByte-CMP-CMP- DE: "\x00\x00\x00\x00\x00\x00\x00\x00"-"ZN_2016"-
=================================================================
==3116==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fff17562128 at pc 0x0000004bf479 bp 0x7fff17561b70 sp 0x7fff17561320
WRITE of size 1023 at 0x7fff17562128 thread T0
    #0 0x4bf478 in __asan_memmove /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors.cc:463
    #1 0x513dd0 in unsigned char* std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<unsigned char>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:384:6
    #2 0x513ca2 in unsigned char* std::__copy_move_a<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:401:14
    #3 0x513c00 in unsigned char* std::__copy_move_a2<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:438:18
    #4 0x513a43 in unsigned char* std::copy<unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:470:15
    #5 0x5136c9 in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:61:3
    #6 0x513963 in LLVMFuzzerTestOneInput /home/fuzzer/projects/libfuzzer-workshop/lessons/04/second_fuzzer.cc:10:3
    #7 0x51e4c3 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:451:13
    #8 0x51e6f0 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:408:3
    #9 0x51f0db in fuzzer::Fuzzer::MutateAndTestOne() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:587:30
    #10 0x51f337 in fuzzer::Fuzzer::Loop() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:615:5
    #11 0x517284 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerDriver.cpp:644:6
    #12 0x513f60 in main /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerMain.cpp:20:10
    #13 0x7f9d3cc2982f in __libc_start_main /build/glibc-t3gR2i/glibc-2.23/csu/../csu/libc-start.c:291
    #14 0x41c868 in _start (/home/fuzzer/projects/libfuzzer-workshop/lessons/04/second_fuzzer+0x41c868)

Address 0x7fff17562128 is located in stack of thread T0 at offset 1128 in frame
    #0 0x51338f in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:42

  This frame has 3 object(s):
    [32, 64) 'header'
    [96, 97) 'ref.tmp'
    [112, 1128) 'body' <== Memory access at offset 1128 overflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors.cc:463 in __asan_memmove
Shadow bytes around the buggy address:
  0x100062ea43d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100062ea43e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100062ea43f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100062ea4400: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100062ea4410: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x100062ea4420: 00 00 00 00 00[f3]f3 f3 f3 f3 f3 f3 f3 f3 f3 f3
  0x100062ea4430: f3 f3 f3 f3 f3 f3 f3 f3 00 00 00 00 00 00 00 00
  0x100062ea4440: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100062ea4450: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100062ea4460: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100062ea4470: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==3116==ABORTING
MS: 1 CrossOver-; base unit: ddcf4d4dfdecfdf0b110e3dfa264958fb8733a86
artifact_prefix='./'; Test unit written to ./crash-ceca2b61f52a28b1c3752ac1b632245622344456
```

</details>

- 单独测试 `true` 的情况下仍为 22
- 同时测试 `false` 和 `true` 的情况下为 22，减少了 1
- 说明覆盖率就是运行到的基本块的总数

## 被封装了的逻辑稍微复杂的溢出

在上一节函数的基础上加了一层封装，接受 flags 参数，然而实际上也就 `true` 和 `false` 两种调用

```c
constexpr std::size_t kZn2016VerifyHashFlag = 0x0001000;

bool VulnerableFunction3(const uint8_t* data, size_t size, std::size_t flags) {
  bool verify_hash = flags & kZn2016VerifyHashFlag;
  return VulnerableFunction2(data, size, verify_hash);
}
```

教程给出的方法是将输入的 `data` 转化为 string 类型并做哈希操作，以达到随机化的目的
- 这个不是很理解，倒是 libfuzzer 的文档说非确定性测试效率低下
- 可能是因为 flag 的大小是数可以有很多不同的，而布尔值只有俩（？）

```cpp
#include "vulnerable_functions.h"

#include <functional>
#include <string>

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  std::string data_string(reinterpret_cast<const char*>(data), size);
  auto data_hash = std::hash<std::string>()(data_string);

  std::size_t flags = static_cast<size_t>(data_hash);
  VulnerableFunction3(data, size, flags);
  return 0;
}
```

阅读源码可以发现只是多了个与操作，遍历 `VulnerableFunction2` 的只需要 `true` 和 `false` ，因此可以直接构造 `0x0` 、`0x1001`即可

```cpp
#include "vulnerable_functions.h"

#include <functional>
#include <string>

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  VulnerableFunction3(data, size, 0x0000000);   // false
  VulnerableFunction3(data, size, 0x0001000);   // true
  return 0;
}
```

编译

```bash
clang++ -g -std=c++11 -fsanitize=address -fsanitize-coverage=trace-pc-guard \
    third_fuzzer.cc ../../libFuzzer/libFuzzer.a \
    -o third_fuzzer
```

运行时同样加上 `-max_len=1024` 这个参数
- 两种方法都能触发程序崩溃
- 不同点是使用 hash 函数的 fuzzer 路径覆盖率更高（27），只使用两个值的路径覆盖率只有 23

```bash
mkdir corpus3
./third_fuzzer corpus3 -max_len=1024
```

<details>
<summary> 运行结果 </summary><br>

```bash
# hash
INFO: Seed: 1682346718
INFO: Loaded 1 modules (41 guards): [0x772ec0, 0x772f64), 
Loading corpus dir: corpus3
INFO: A corpus is not provided, starting from an empty corpus
#0	READ units: 1
#1	INITED cov: 8 ft: 8 corp: 1/1b exec/s: 0 rss: 27Mb
#7	NEW    cov: 9 ft: 9 corp: 2/22b exec/s: 0 rss: 27Mb L: 21 MS: 1 InsertRepeatedBytes-
#45996	NEW    cov: 27 ft: 27 corp: 3/31b exec/s: 0 rss: 57Mb L: 9 MS: 5 ChangeByte-CMP-ShuffleBytes-CopyPart-CMP- DE: "\x00\x00\x00\x00\x00\x00\x00\x00"-"ZN_2016"-
=================================================================
==3273==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe36479128 at pc 0x0000004bf579 bp 0x7ffe36478b70 sp 0x7ffe36478320
WRITE of size 1023 at 0x7ffe36479128 thread T0
    #0 0x4bf578 in __asan_memmove /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors.cc:463
    #1 0x514280 in unsigned char* std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<unsigned char>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:384:6
    #2 0x514152 in unsigned char* std::__copy_move_a<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:401:14
    #3 0x5140b0 in unsigned char* std::__copy_move_a2<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:438:18
    #4 0x513de3 in unsigned char* std::copy<unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:470:15
    #5 0x5137c9 in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:61:3
    #6 0x513a0b in VulnerableFunction3(unsigned char const*, unsigned long, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:71:10
    #7 0x513bb8 in LLVMFuzzerTestOneInput /home/fuzzer/projects/libfuzzer-workshop/lessons/04/third_fuzzer.cc:17:3
    #8 0x51e963 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:451:13
    #9 0x51eb90 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:408:3
    #10 0x51f57b in fuzzer::Fuzzer::MutateAndTestOne() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:587:30
    #11 0x51f7d7 in fuzzer::Fuzzer::Loop() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:615:5
    #12 0x517734 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerDriver.cpp:644:6
    #13 0x514410 in main /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerMain.cpp:20:10
    #14 0x7f98d258d82f in __libc_start_main /build/glibc-t3gR2i/glibc-2.23/csu/../csu/libc-start.c:291
    #15 0x41c968 in _start (/home/fuzzer/projects/libfuzzer-workshop/lessons/04/third_fuzzer+0x41c968)

Address 0x7ffe36479128 is located in stack of thread T0 at offset 1128 in frame
    #0 0x51348f in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:42

  This frame has 3 object(s):
    [32, 64) 'header'
    [96, 97) 'ref.tmp'
    [112, 1128) 'body' <== Memory access at offset 1128 overflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors.cc:463 in __asan_memmove
Shadow bytes around the buggy address:
  0x100046c871d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100046c871e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100046c871f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100046c87200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100046c87210: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x100046c87220: 00 00 00 00 00[f3]f3 f3 f3 f3 f3 f3 f3 f3 f3 f3
  0x100046c87230: f3 f3 f3 f3 f3 f3 f3 f3 00 00 00 00 00 00 00 00
  0x100046c87240: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100046c87250: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100046c87260: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 00 00
  0x100046c87270: f2 f2 f2 f2 01 f2 01 f3 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==3273==ABORTING
MS: 3 ChangeBit-InsertByte-CrossOver-; base unit: ddcf4d4dfdecfdf0b110e3dfa264958fb8733a86
artifact_prefix='./'; Test unit written to ./crash-a10c0bd0db3aca0a4b31364645152a852237d270


# 0x0000000(false)、0x0001000(true)
INFO: Seed: 3483529102
INFO: Loaded 1 modules (35 guards): [0x771ea0, 0x771f2c), 
Loading corpus dir: corpus3
INFO: A corpus is not provided, starting from an empty corpus
#0	READ units: 1
#1	INITED cov: 4 ft: 4 corp: 1/1b exec/s: 0 rss: 29Mb
#10	NEW    cov: 5 ft: 5 corp: 2/81b exec/s: 0 rss: 29Mb L: 80 MS: 4 InsertByte-EraseBytes-CopyPart-InsertRepeatedBytes-
#28255	NEW    cov: 23 ft: 23 corp: 3/91b exec/s: 0 rss: 39Mb L: 10 MS: 4 ChangeBinInt-InsertByte-CMP-CMP- DE: "\x00\x00\x00\x00\x00\x00\x00\x00"-"ZN_2016"-
=================================================================
==3326==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffdaf8b6168 at pc 0x0000004bf479 bp 0x7ffdaf8b5bb0 sp 0x7ffdaf8b5360
WRITE of size 1023 at 0x7ffdaf8b6168 thread T0
    #0 0x4bf478 in __asan_memmove /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors.cc:463
    #1 0x513dd0 in unsigned char* std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<unsigned char>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:384:6
    #2 0x513ca2 in unsigned char* std::__copy_move_a<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:401:14
    #3 0x513c00 in unsigned char* std::__copy_move_a2<false, unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:438:18
    #4 0x513a43 in unsigned char* std::copy<unsigned char const*, unsigned char*>(unsigned char const*, unsigned char const*, unsigned char*) /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../include/c++/5.4.0/bits/stl_algobase.h:470:15
    #5 0x5136c9 in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:61:3
    #6 0x51390b in VulnerableFunction3(unsigned char const*, unsigned long, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:71:10
    #7 0x513962 in LLVMFuzzerTestOneInput /home/fuzzer/projects/libfuzzer-workshop/lessons/04/third_fuzzer.cc:13:3
    #8 0x51e4c3 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:451:13
    #9 0x51e6f0 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:408:3
    #10 0x51f0db in fuzzer::Fuzzer::MutateAndTestOne() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:587:30
    #11 0x51f337 in fuzzer::Fuzzer::Loop() /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerLoop.cpp:615:5
    #12 0x517284 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerDriver.cpp:644:6
    #13 0x513f60 in main /home/fuzzer/projects/libfuzzer-workshop/libFuzzer/Fuzzer/./FuzzerMain.cpp:20:10
    #14 0x7f617956282f in __libc_start_main /build/glibc-t3gR2i/glibc-2.23/csu/../csu/libc-start.c:291
    #15 0x41c868 in _start (/home/fuzzer/projects/libfuzzer-workshop/lessons/04/third_fuzzer+0x41c868)

Address 0x7ffdaf8b6168 is located in stack of thread T0 at offset 1128 in frame
    #0 0x51338f in VulnerableFunction2(unsigned char const*, unsigned long, bool) /home/fuzzer/projects/libfuzzer-workshop/lessons/04/./vulnerable_functions.h:42

  This frame has 3 object(s):
    [32, 64) 'header'
    [96, 97) 'ref.tmp'
    [112, 1128) 'body' <== Memory access at offset 1128 overflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow /home/fuzzer/projects/src/llvm/projects/compiler-rt/lib/asan/asan_interceptors.cc:463 in __asan_memmove
Shadow bytes around the buggy address:
  0x100035f0ebd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100035f0ebe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100035f0ebf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100035f0ec00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100035f0ec10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x100035f0ec20: 00 00 00 00 00 00 00 00 00 00 00 00 00[f3]f3 f3
  0x100035f0ec30: f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3 f3
  0x100035f0ec40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100035f0ec50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100035f0ec60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100035f0ec70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==3326==ABORTING
MS: 2 ShuffleBytes-CrossOver-; base unit: 6323eb3a825b2f9dfaf4a159f352910736bf105b
artifact_prefix='./'; Test unit written to ./crash-c7e6cc7b93451f5be8bcd21fe4ff92ce0fab80a3
```

</details>

## 总结

- Linux 环境下的编译并不了解，`clang++` 、`gcc` 什么的（想起了前两天面试老师问 Linux 底下有啥编译器，我：没在Linux底下编程过）
  - `clang++` 的参数真的多
- AddressSanitizer 很强的工具，就是官方文档不够详细，~~我这个小白~~没完全看懂输出
- 符号化工具提供了很大的便利，直接就能看出来是在哪个文件哪个函数产生的 crash 

## 参阅
- [AddressSanitizer](http://clang.llvm.org/docs/AddressSanitizer.html)
- [SanitizerCoverage](https://clang.llvm.org/docs/SanitizerCoverage.html)
- [libfuzzer & LLVM 初探](https://p1umer.github.io/2019/02/20/libfuzzer%20&%20LLVM%20%E5%88%9D%E6%8E%A2/)
